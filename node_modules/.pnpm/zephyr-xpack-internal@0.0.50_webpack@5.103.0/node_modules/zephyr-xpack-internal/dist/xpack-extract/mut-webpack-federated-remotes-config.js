"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mutWebpackFederatedRemotesConfig = mutWebpackFederatedRemotesConfig;
const zephyr_agent_1 = require("zephyr-agent");
const extract_federated_dependency_pairs_1 = require("./extract-federated-dependency-pairs");
const index_1 = require("./index");
const iterate_federated_remote_config_1 = require("./iterate-federated-remote-config");
function mutWebpackFederatedRemotesConfig(zephyr_engine, config, resolvedDependencyPairs, delegate_module_template = index_1.xpack_delegate_module_template) {
    if (!resolvedDependencyPairs?.length) {
        (0, zephyr_agent_1.ze_log)(`No resolved dependency pairs found, skipping...`);
        return;
    }
    (0, iterate_federated_remote_config_1.iterateFederatedRemoteConfig)(config, (remotesConfig) => {
        const remotes = remotesConfig?.remotes;
        if (!remotes) {
            (0, zephyr_agent_1.ze_log)(`No remotes found for plugin: ${JSON.stringify(remotesConfig, null, 2)}`, 'skipping...');
            return;
        }
        const library_type = remotesConfig.library?.type ?? 'var';
        (0, zephyr_agent_1.ze_log)(`Library type: ${library_type}`);
        const remoteEntries = (0, extract_federated_dependency_pairs_1.parseRemotesAsEntries)(remotes);
        remoteEntries.forEach((remote) => {
            const [remote_name, remote_version] = remote;
            const resolved_dep = resolvedDependencyPairs.find((dep) => {
                const nameMatch = dep.name === remote_name;
                const versionMatch = dep.version === 'latest' ? true : dep.version === remote_version;
                return nameMatch && versionMatch;
            });
            (0, zephyr_agent_1.ze_log)(`remote_name: ${remote_name}, remote_version: ${remote_version}`);
            if (!resolved_dep) {
                (0, zephyr_agent_1.ze_log)(`Resolved dependency pair not found for remote: ${JSON.stringify(remote, null, 2)}`, 'skipping...');
                return;
            }
            // todo: this is a version with named export logic, we should take this into account later
            const [v_app] = remote_version.includes('@')
                ? remote_version.split('@')
                : [remote_name];
            (0, zephyr_agent_1.ze_log)(`v_app: ${v_app}`);
            if (v_app) {
                resolved_dep.remote_entry_url = [v_app, resolved_dep.remote_entry_url].join('@');
                (0, zephyr_agent_1.ze_log)(`Adding version to remote entry url: ${resolved_dep.remote_entry_url}`);
            }
            resolved_dep.library_type = library_type;
            resolved_dep.name = remote_name;
            const runtimeCode = (0, index_1.createMfRuntimeCode)(zephyr_engine, resolved_dep, delegate_module_template);
            if (Array.isArray(remotes)) {
                const remoteIndex = remotes.indexOf(remote_name);
                if (remoteIndex === -1)
                    return;
                // @ts-expect-error - Nx's ModuleFederationPlugin has different remote types
                remotes.splice(remoteIndex, 1, [remote_name, runtimeCode]);
                return;
            }
            remotes[remote_name] = runtimeCode;
        });
        (0, zephyr_agent_1.ze_log)(`Set runtime code for remotes: ${remotes}`);
    });
}
//# sourceMappingURL=mut-webpack-federated-remotes-config.js.map