"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractFederatedDependencyPairs = extractFederatedDependencyPairs;
exports.parseRemotesAsEntries = parseRemotesAsEntries;
const zephyr_agent_1 = require("zephyr-agent");
const iterate_federated_remote_config_1 = require("./iterate-federated-remote-config");
function extractFederatedDependencyPairs(config) {
    const depsPairs = [];
    const { zephyrDependencies } = (0, zephyr_agent_1.readPackageJson)(config.context ?? process.cwd());
    if (zephyrDependencies) {
        Object.entries(zephyrDependencies).map(([name, version]) => {
            depsPairs.push({ name, version });
        });
    }
    (0, iterate_federated_remote_config_1.iterateFederatedRemoteConfig)(config, (remotesConfig) => {
        if (!remotesConfig?.remotes)
            return;
        const remoteEntries = parseRemotesAsEntries(remotesConfig.remotes);
        remoteEntries.forEach(([remote_name, remote_version]) => {
            depsPairs.push({
                name: remote_name,
                version: remote_version,
            });
        });
    });
    return depsPairs
        .flat()
        .filter((dep) => (0, zephyr_agent_1.is_zephyr_dependency_pair)(dep));
}
/** Returns an Array of [remote_name, remote_version] */
function parseRemotesAsEntries(remotes) {
    if (!remotes)
        return [];
    const remotePairs = [];
    const remoteEntries = Array.isArray(remotes) ? remotes : Object.entries(remotes);
    remoteEntries.map((remote) => {
        if (Array.isArray(remote)) {
            // Case where remotes are declared as:
            // Record<remote_name: string, remote_version: string | RemotesConfig>
            // e.g. ['remote_name', { url: 'remote_url' }]
            const version = typeof remote[1] === 'string' ? remote[1] : JSON.stringify(remote[1]);
            remotePairs.push([remote[0], version]);
        }
        else if (typeof remote === 'string') {
            // Case where remotes are declared as string (Nx's default remotes)
            remotePairs.push([remote, remote]);
        }
        else {
            // Fallback case where remotes are nested RemotesConfig objects
            Object.entries(remote).forEach(([name, config]) => {
                const version = typeof config === 'string' ? config : JSON.stringify(config);
                remotePairs.push([name, version]);
            });
        }
    });
    return remotePairs;
}
//# sourceMappingURL=extract-federated-dependency-pairs.js.map